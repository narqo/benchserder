// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: event.go

package benchserder

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/narqo/benchserder/internal/fraud"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *Event) MarshalFFJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Event) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"AppToken":`)
	fflib.WriteJsonString(buf, string(j.AppToken))
	buf.WriteString(`,"Tracker":`)
	fflib.WriteJsonString(buf, string(j.Tracker))
	buf.WriteString(`,"Adid":`)
	fflib.WriteJsonString(buf, string(j.Adid))
	buf.WriteString(`,"FacebookAttributionId":`)
	fflib.WriteJsonString(buf, string(j.FacebookAttributionId))
	buf.WriteString(`,"FacebookAnonId":`)
	fflib.WriteJsonString(buf, string(j.FacebookAnonId))
	buf.WriteString(`,"TrackingEnabled":`)
	fflib.WriteJsonString(buf, string(j.TrackingEnabled))
	buf.WriteString(`,"ClickTime":`)

	{

		obj, err = j.ClickTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"FirstSessionTime":`)

	{

		obj, err = j.FirstSessionTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"LastSessionTime":`)

	{

		obj, err = j.LastSessionTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"LastEventTime":`)

	{

		obj, err = j.LastEventTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"LastRevenueTime":`)

	{

		obj, err = j.LastRevenueTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"CreatedAt":`)

	{

		obj, err = j.CreatedAt.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"ReceivedAt":`)

	{

		obj, err = j.ReceivedAt.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if true {
		buf.WriteString(`"InstallTime":`)

		{

			obj, err = j.InstallTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if len(j.InstallTracker) != 0 {
		buf.WriteString(`"InstallTracker":`)
		fflib.WriteJsonString(buf, string(j.InstallTracker))
		buf.WriteByte(',')
	}
	if len(j.InstallCountry) != 0 {
		buf.WriteString(`"InstallCountry":`)
		fflib.WriteJsonString(buf, string(j.InstallCountry))
		buf.WriteByte(',')
	}
	if true {
		/* Struct fall back. type=nullable.Bool kind=struct */
		buf.WriteString(`"InstallImpressionBased":`)
		err = buf.Encode(&j.InstallImpressionBased)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"EventToken":`)
	fflib.WriteJsonString(buf, string(j.EventToken))
	/* Struct fall back. type=money.Amount kind=struct */
	buf.WriteString(`,"RevenueData":`)
	err = buf.Encode(&j.RevenueData)
	if err != nil {
		return err
	}
	buf.WriteString(`,"DeviceType":`)
	fflib.WriteJsonString(buf, string(j.DeviceType))
	buf.WriteString(`,"Environment":`)
	fflib.WriteJsonString(buf, string(j.Environment))
	/* Struct fall back. type=nullable.Int kind=struct */
	buf.WriteString(`,"NullSdkLevel":`)
	err = buf.Encode(&j.NullSdkLevel)
	if err != nil {
		return err
	}
	buf.WriteString(`,"ZoneOffset":`)
	fflib.FormatBits2(buf, uint64(j.ZoneOffset), 10, j.ZoneOffset < 0)
	buf.WriteString(`,"FraudKind":`)
	fflib.FormatBits2(buf, uint64(j.FraudKind), 10, false)
	buf.WriteString(`,"PingbackUrl":`)
	fflib.WriteJsonString(buf, string(j.PingbackUrl))
	if j.CallbackData != nil {
		/* Struct fall back. type=callback.Data kind=struct */
		buf.WriteString(`,"CallbackData":`)
		err = buf.Encode(j.CallbackData)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`,"CallbackData":null`)
	}
	buf.WriteString(`,"FirstOsName":`)
	fflib.WriteJsonString(buf, string(j.FirstOsName))
	buf.WriteString(`,"FirstCountry":`)
	fflib.WriteJsonString(buf, string(j.FirstCountry))
	buf.WriteString(`,"FirstDeviceType":`)
	fflib.WriteJsonString(buf, string(j.FirstDeviceType))
	if j.ImpressionBased {
		buf.WriteString(`,"ImpressionBased":true`)
	} else {
		buf.WriteString(`,"ImpressionBased":false`)
	}
	if j.DeviceReattributed {
		buf.WriteString(`,"DeviceReattributed":true`)
	} else {
		buf.WriteString(`,"DeviceReattributed":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtEventbase = iota
	ffjtEventnosuchkey

	ffjtEventAppToken

	ffjtEventTracker

	ffjtEventAdid

	ffjtEventFacebookAttributionId

	ffjtEventFacebookAnonId

	ffjtEventTrackingEnabled

	ffjtEventClickTime

	ffjtEventFirstSessionTime

	ffjtEventLastSessionTime

	ffjtEventLastEventTime

	ffjtEventLastRevenueTime

	ffjtEventCreatedAt

	ffjtEventReceivedAt

	ffjtEventInstallTime

	ffjtEventInstallTracker

	ffjtEventInstallCountry

	ffjtEventInstallImpressionBased

	ffjtEventEventToken

	ffjtEventRevenueData

	ffjtEventDeviceType

	ffjtEventEnvironment

	ffjtEventNullSdkLevel

	ffjtEventZoneOffset

	ffjtEventFraudKind

	ffjtEventPingbackUrl

	ffjtEventCallbackData

	ffjtEventFirstOsName

	ffjtEventFirstCountry

	ffjtEventFirstDeviceType

	ffjtEventImpressionBased

	ffjtEventDeviceReattributed
)

var ffjKeyEventAppToken = []byte("AppToken")

var ffjKeyEventTracker = []byte("Tracker")

var ffjKeyEventAdid = []byte("Adid")

var ffjKeyEventFacebookAttributionId = []byte("FacebookAttributionId")

var ffjKeyEventFacebookAnonId = []byte("FacebookAnonId")

var ffjKeyEventTrackingEnabled = []byte("TrackingEnabled")

var ffjKeyEventClickTime = []byte("ClickTime")

var ffjKeyEventFirstSessionTime = []byte("FirstSessionTime")

var ffjKeyEventLastSessionTime = []byte("LastSessionTime")

var ffjKeyEventLastEventTime = []byte("LastEventTime")

var ffjKeyEventLastRevenueTime = []byte("LastRevenueTime")

var ffjKeyEventCreatedAt = []byte("CreatedAt")

var ffjKeyEventReceivedAt = []byte("ReceivedAt")

var ffjKeyEventInstallTime = []byte("InstallTime")

var ffjKeyEventInstallTracker = []byte("InstallTracker")

var ffjKeyEventInstallCountry = []byte("InstallCountry")

var ffjKeyEventInstallImpressionBased = []byte("InstallImpressionBased")

var ffjKeyEventEventToken = []byte("EventToken")

var ffjKeyEventRevenueData = []byte("RevenueData")

var ffjKeyEventDeviceType = []byte("DeviceType")

var ffjKeyEventEnvironment = []byte("Environment")

var ffjKeyEventNullSdkLevel = []byte("NullSdkLevel")

var ffjKeyEventZoneOffset = []byte("ZoneOffset")

var ffjKeyEventFraudKind = []byte("FraudKind")

var ffjKeyEventPingbackUrl = []byte("PingbackUrl")

var ffjKeyEventCallbackData = []byte("CallbackData")

var ffjKeyEventFirstOsName = []byte("FirstOsName")

var ffjKeyEventFirstCountry = []byte("FirstCountry")

var ffjKeyEventFirstDeviceType = []byte("FirstDeviceType")

var ffjKeyEventImpressionBased = []byte("ImpressionBased")

var ffjKeyEventDeviceReattributed = []byte("DeviceReattributed")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Event) UnmarshalFFJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Event) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtEventbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'A':

					if bytes.Equal(ffjKeyEventAppToken, kn) {
						currentKey = ffjtEventAppToken
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventAdid, kn) {
						currentKey = ffjtEventAdid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'C':

					if bytes.Equal(ffjKeyEventClickTime, kn) {
						currentKey = ffjtEventClickTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventCreatedAt, kn) {
						currentKey = ffjtEventCreatedAt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventCallbackData, kn) {
						currentKey = ffjtEventCallbackData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeyEventDeviceType, kn) {
						currentKey = ffjtEventDeviceType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventDeviceReattributed, kn) {
						currentKey = ffjtEventDeviceReattributed
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffjKeyEventEventToken, kn) {
						currentKey = ffjtEventEventToken
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventEnvironment, kn) {
						currentKey = ffjtEventEnvironment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffjKeyEventFacebookAttributionId, kn) {
						currentKey = ffjtEventFacebookAttributionId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventFacebookAnonId, kn) {
						currentKey = ffjtEventFacebookAnonId
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventFirstSessionTime, kn) {
						currentKey = ffjtEventFirstSessionTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventFraudKind, kn) {
						currentKey = ffjtEventFraudKind
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventFirstOsName, kn) {
						currentKey = ffjtEventFirstOsName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventFirstCountry, kn) {
						currentKey = ffjtEventFirstCountry
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventFirstDeviceType, kn) {
						currentKey = ffjtEventFirstDeviceType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffjKeyEventInstallTime, kn) {
						currentKey = ffjtEventInstallTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventInstallTracker, kn) {
						currentKey = ffjtEventInstallTracker
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventInstallCountry, kn) {
						currentKey = ffjtEventInstallCountry
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventInstallImpressionBased, kn) {
						currentKey = ffjtEventInstallImpressionBased
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventImpressionBased, kn) {
						currentKey = ffjtEventImpressionBased
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'L':

					if bytes.Equal(ffjKeyEventLastSessionTime, kn) {
						currentKey = ffjtEventLastSessionTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventLastEventTime, kn) {
						currentKey = ffjtEventLastEventTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventLastRevenueTime, kn) {
						currentKey = ffjtEventLastRevenueTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffjKeyEventNullSdkLevel, kn) {
						currentKey = ffjtEventNullSdkLevel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyEventPingbackUrl, kn) {
						currentKey = ffjtEventPingbackUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffjKeyEventReceivedAt, kn) {
						currentKey = ffjtEventReceivedAt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventRevenueData, kn) {
						currentKey = ffjtEventRevenueData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeyEventTracker, kn) {
						currentKey = ffjtEventTracker
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyEventTrackingEnabled, kn) {
						currentKey = ffjtEventTrackingEnabled
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'Z':

					if bytes.Equal(ffjKeyEventZoneOffset, kn) {
						currentKey = ffjtEventZoneOffset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventDeviceReattributed, kn) {
					currentKey = ffjtEventDeviceReattributed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventImpressionBased, kn) {
					currentKey = ffjtEventImpressionBased
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventFirstDeviceType, kn) {
					currentKey = ffjtEventFirstDeviceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventFirstCountry, kn) {
					currentKey = ffjtEventFirstCountry
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventFirstOsName, kn) {
					currentKey = ffjtEventFirstOsName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventCallbackData, kn) {
					currentKey = ffjtEventCallbackData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventPingbackUrl, kn) {
					currentKey = ffjtEventPingbackUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventFraudKind, kn) {
					currentKey = ffjtEventFraudKind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventZoneOffset, kn) {
					currentKey = ffjtEventZoneOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventNullSdkLevel, kn) {
					currentKey = ffjtEventNullSdkLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventEnvironment, kn) {
					currentKey = ffjtEventEnvironment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventDeviceType, kn) {
					currentKey = ffjtEventDeviceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventRevenueData, kn) {
					currentKey = ffjtEventRevenueData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventEventToken, kn) {
					currentKey = ffjtEventEventToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventInstallImpressionBased, kn) {
					currentKey = ffjtEventInstallImpressionBased
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventInstallCountry, kn) {
					currentKey = ffjtEventInstallCountry
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventInstallTracker, kn) {
					currentKey = ffjtEventInstallTracker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventInstallTime, kn) {
					currentKey = ffjtEventInstallTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventReceivedAt, kn) {
					currentKey = ffjtEventReceivedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventCreatedAt, kn) {
					currentKey = ffjtEventCreatedAt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventLastRevenueTime, kn) {
					currentKey = ffjtEventLastRevenueTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventLastEventTime, kn) {
					currentKey = ffjtEventLastEventTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventLastSessionTime, kn) {
					currentKey = ffjtEventLastSessionTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventFirstSessionTime, kn) {
					currentKey = ffjtEventFirstSessionTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventClickTime, kn) {
					currentKey = ffjtEventClickTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventTrackingEnabled, kn) {
					currentKey = ffjtEventTrackingEnabled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventFacebookAnonId, kn) {
					currentKey = ffjtEventFacebookAnonId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventFacebookAttributionId, kn) {
					currentKey = ffjtEventFacebookAttributionId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyEventAdid, kn) {
					currentKey = ffjtEventAdid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventTracker, kn) {
					currentKey = ffjtEventTracker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyEventAppToken, kn) {
					currentKey = ffjtEventAppToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtEventnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtEventAppToken:
					goto handle_AppToken

				case ffjtEventTracker:
					goto handle_Tracker

				case ffjtEventAdid:
					goto handle_Adid

				case ffjtEventFacebookAttributionId:
					goto handle_FacebookAttributionId

				case ffjtEventFacebookAnonId:
					goto handle_FacebookAnonId

				case ffjtEventTrackingEnabled:
					goto handle_TrackingEnabled

				case ffjtEventClickTime:
					goto handle_ClickTime

				case ffjtEventFirstSessionTime:
					goto handle_FirstSessionTime

				case ffjtEventLastSessionTime:
					goto handle_LastSessionTime

				case ffjtEventLastEventTime:
					goto handle_LastEventTime

				case ffjtEventLastRevenueTime:
					goto handle_LastRevenueTime

				case ffjtEventCreatedAt:
					goto handle_CreatedAt

				case ffjtEventReceivedAt:
					goto handle_ReceivedAt

				case ffjtEventInstallTime:
					goto handle_InstallTime

				case ffjtEventInstallTracker:
					goto handle_InstallTracker

				case ffjtEventInstallCountry:
					goto handle_InstallCountry

				case ffjtEventInstallImpressionBased:
					goto handle_InstallImpressionBased

				case ffjtEventEventToken:
					goto handle_EventToken

				case ffjtEventRevenueData:
					goto handle_RevenueData

				case ffjtEventDeviceType:
					goto handle_DeviceType

				case ffjtEventEnvironment:
					goto handle_Environment

				case ffjtEventNullSdkLevel:
					goto handle_NullSdkLevel

				case ffjtEventZoneOffset:
					goto handle_ZoneOffset

				case ffjtEventFraudKind:
					goto handle_FraudKind

				case ffjtEventPingbackUrl:
					goto handle_PingbackUrl

				case ffjtEventCallbackData:
					goto handle_CallbackData

				case ffjtEventFirstOsName:
					goto handle_FirstOsName

				case ffjtEventFirstCountry:
					goto handle_FirstCountry

				case ffjtEventFirstDeviceType:
					goto handle_FirstDeviceType

				case ffjtEventImpressionBased:
					goto handle_ImpressionBased

				case ffjtEventDeviceReattributed:
					goto handle_DeviceReattributed

				case ffjtEventnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AppToken:

	/* handler: j.AppToken type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.AppToken = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tracker:

	/* handler: j.Tracker type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Tracker = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Adid:

	/* handler: j.Adid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Adid = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FacebookAttributionId:

	/* handler: j.FacebookAttributionId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FacebookAttributionId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FacebookAnonId:

	/* handler: j.FacebookAnonId type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FacebookAnonId = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TrackingEnabled:

	/* handler: j.TrackingEnabled type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.TrackingEnabled = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClickTime:

	/* handler: j.ClickTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ClickTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstSessionTime:

	/* handler: j.FirstSessionTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.FirstSessionTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastSessionTime:

	/* handler: j.LastSessionTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.LastSessionTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastEventTime:

	/* handler: j.LastEventTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.LastEventTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastRevenueTime:

	/* handler: j.LastRevenueTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.LastRevenueTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedAt:

	/* handler: j.CreatedAt type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CreatedAt.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReceivedAt:

	/* handler: j.ReceivedAt type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ReceivedAt.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstallTime:

	/* handler: j.InstallTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.InstallTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstallTracker:

	/* handler: j.InstallTracker type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InstallTracker = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstallCountry:

	/* handler: j.InstallCountry type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InstallCountry = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstallImpressionBased:

	/* handler: j.InstallImpressionBased type=nullable.Bool kind=struct quoted=false*/

	{
		/* Falling back. type=nullable.Bool kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InstallImpressionBased)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EventToken:

	/* handler: j.EventToken type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.EventToken = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RevenueData:

	/* handler: j.RevenueData type=money.Amount kind=struct quoted=false*/

	{
		/* Falling back. type=money.Amount kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.RevenueData)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeviceType:

	/* handler: j.DeviceType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.DeviceType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Environment:

	/* handler: j.Environment type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Environment = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NullSdkLevel:

	/* handler: j.NullSdkLevel type=nullable.Int kind=struct quoted=false*/

	{
		/* Falling back. type=nullable.Int kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.NullSdkLevel)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ZoneOffset:

	/* handler: j.ZoneOffset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ZoneOffset = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FraudKind:

	/* handler: j.FraudKind type=fraud.Kind kind=uint8 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for Kind", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 8)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FraudKind = fraud.Kind(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PingbackUrl:

	/* handler: j.PingbackUrl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PingbackUrl = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackData:

	/* handler: j.CallbackData type=callback.Data kind=struct quoted=false*/

	{
		/* Falling back. type=callback.Data kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.CallbackData)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstOsName:

	/* handler: j.FirstOsName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstOsName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstCountry:

	/* handler: j.FirstCountry type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstCountry = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstDeviceType:

	/* handler: j.FirstDeviceType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstDeviceType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImpressionBased:

	/* handler: j.ImpressionBased type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ImpressionBased = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ImpressionBased = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeviceReattributed:

	/* handler: j.DeviceReattributed type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DeviceReattributed = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DeviceReattributed = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
